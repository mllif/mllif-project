using System.Text;
using Microsoft.CodeAnalysis;

namespace MLLIFCSharpFront;

[Generator(LanguageNames.CSharp)]
public class BindGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static context =>
        {
            context.AddSource("ExportAttribute.cs",
                """
                // <auto-generated />
                using System;

                namespace MLLIF {
                    [AttributeUsage(AttributeTargets.Method, AllowMultiple=false, Inherited=false)]
                    internal sealed class ExportAttribute : Attribute {}
                }
                """);
        });

        var source = context.SyntaxProvider.ForAttributeWithMetadataName(
            "MLLIF.ExportAttribute",
            static (_,       _) => true,
            static (context, _) => context);

        context.RegisterSourceOutput(source, Emit);
    }

    private static string GetFullName(ISymbol symbol)
    {
        var queue = new Stack<string>();
        while (symbol is INamespaceOrTypeSymbol or IMethodSymbol)
        {
            if (!string.IsNullOrWhiteSpace(symbol.Name))
                queue.Push(symbol.Name);
            symbol = symbol.ContainingSymbol;
        }

        var builder = new StringBuilder();
        for (var first = true; queue.Count > 0; first = false)
        {
            if (!first)
                builder.Append('.');
            builder.Append(queue.Pop());
        }

        return builder.ToString();
    }

    private static string ToNativeType(ITypeSymbol type)
    {
        if (type.IsReferenceType)
            return "System.IntPtr";

        return type.ToDisplayString();
    }

    private static string? ToCode(ITypeSymbol type)
    {
        if (type.IsReferenceType)
            return "void*";

        switch (GetFullName(type))
        {
            case "System.SByte": return "s8";
            case "System.Int16": return "s16";
            case "System.Int32": return "s32";
            case "System.Int64": return "s64";

            case "System.Byte":   return "u8";
            case "System.UInt16": return "u16";
            case "System.UInt32": return "u32";
            case "System.UInt64": return "u64";

            case "System.Half":   return "fp16";
            case "System.Single": return "fp32";
            case "System.Double": return "fp64";

            default: return null;
        }
    }

    private static Diagnostic UnsupportedType(ITypeSymbol type)
        => Diagnostic.Create(
            "MLLIF01", "",
            $"'{GetFullName(type)}' is not supported by MLLIF",
            DiagnosticSeverity.Error, DiagnosticSeverity.Error,
            true, 0);

    private static Diagnostic CannotMangle(IMethodSymbol method)
        => Diagnostic.Create(
            "MLLIF02", "",
            $"'{method.ToDisplayString()}' cannot be mangled",
            DiagnosticSeverity.Error, DiagnosticSeverity.Error,
            true, 0);

    private static string? MangleName(SourceProductionContext spc, IMethodSymbol method)
    {
        var builder = new StringBuilder();
        builder.Append("__mllif__").Append(method.Name).Append('_');

        foreach (var param in method.Parameters)
        {
            if (ToCode(param.Type) is not { } code)
            {
                spc.ReportDiagnostic(UnsupportedType(param.Type));
                return null;
            }

            builder.Append('_').Append(code.Replace('*', 'p'));
        }

        return builder.ToString();
    }

    private void Emit(SourceProductionContext spc, GeneratorAttributeSyntaxContext gasc)
    {
        var symbol = (IMethodSymbol)gasc.TargetSymbol;

        var builder = new StringBuilder();
        builder.Append("\tpublic static ");
        builder.Append(ToNativeType(symbol.ReturnType));
        builder.Append(' ');

        if (MangleName(spc, symbol) is not { } mangling)
        {
            spc.ReportDiagnostic(CannotMangle(symbol));
            return;
        }

        builder.Append(mangling);
        builder.Append('(');

        if (!symbol.IsStatic)
        {
            builder.Append("System.IntPtr self");
            if (symbol.Parameters.Length > 0)
                builder.Append(", ");
        }

        for (var i = 0; i < symbol.Parameters.Length; i++)
        {
            if (i > 0)
                builder.Append(", ");

            var param = symbol.Parameters[i];
            builder
                .Append(ToNativeType(param.Type))
                .Append(' ')
                .Append(param.Name);
        }

        builder.Append(") {\n");

        if (!symbol.IsStatic)
            builder.Append("\t\tvar handle = __GCHandle.FromIntPtr(self);\n");

        builder.Append("\t\treturn ");

        if (!symbol.IsStatic)
            builder.Append("(handle.Target as ").Append(symbol.ContainingType.ToDisplayString()).Append(").");

        builder.Append(symbol.Name).Append('(');

        for (var i = 0; i < symbol.Parameters.Length; i++)
        {
            if (i > 0)
                builder.Append(", ");

            var param = symbol.Parameters[i];

            if (param.Type.IsReferenceType)
                builder.Append("__GCHandle.FromIntPtr(");
            builder.Append(param.Name);
            if (param.Type.IsReferenceType)
                builder.Append(").Target as ").Append(param.Type.ToDisplayString());
        }

        builder.Append(");\n");

        builder.Append("\t}\n");

        spc.AddSource($"{symbol.ContainingType.Name}.{symbol.Name}.g.cs",
            $$"""
              namespace {{symbol.ContainingType.ContainingNamespace.ToDisplayString()}};

              using __GCHandle = System.Runtime.InteropServices.GCHandle;
                  
              public partial class {{symbol.ContainingType.Name}} {
              {{builder}}
              }
              """);
    }
}