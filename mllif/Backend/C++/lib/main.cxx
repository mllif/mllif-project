/*
 * Copyright 2025 Yeong-won Seo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "pch.h"

#include <cstring>
#include <memory>

bool Error = false;

std::ostream& errs() {
    Error = true;
    return std::cerr << "\x1b[0;31merror:\x1b[0m ";
}

auto TypeToString(std::string type) -> std::string {
    auto ref = 0;
    while (type.ends_with('*')) {
        type.erase(type.size() - 1);
        ref++;
    }

    if (type.starts_with('/')) {
        for (size_t p; (p = type.find('/')) != std::string::npos; ) {
            type.replace(p, 1, "::");
        }
    } else /* built-ins */ {
        static std::map<std::string, std::string> map = {
#define T_INT(bit) { "s" #bit , "std::int" #bit "_t" }, { "u" #bit , "std::uint" #bit "_t" }
            T_INT(8),
            T_INT(16),
            T_INT(32),
            T_INT(64),
            { "s128", "__int128_t" },
            { "u128", "__uint128_t" },
            { "fp16", "_Float16" },
            { "fp32", "float" },
            { "fp64", "double" },
            { "fp128", "__float128" },
            { "bool", "bool" },
            { "void", "void" }
#undef T_INT
        };

        if (!map.contains(type)) {
            errs() << "unknown type '" << type << "'" << std::endl;
            return "<UNKNOWN>";
        }

        type = map[type];
    }

    for (auto i = 0; i < ref; i++) {
        type += '*';
    }

    return type;
}

auto Indent(size_t size) -> std::string {
    std::string indent(size * 4, ' ');
    return indent;
}

auto Generate(rapidxml::xml_node<> *node, std::ostream &os, size_t indent) -> void;

#define NODE_HANDLER rapidxml::xml_node<> *node, std::ostream &os, size_t indent
static std::map<std::string, void (*)(NODE_HANDLER)> Handlers = {

    {"assembly", [](NODE_HANDLER) {
         os << "// <auto-generated/>\n"
            << "#include <cstdint>";

         for (auto child = node->first_node(); child; child = child->next_sibling()) {
             Generate(child, os, indent);
         }
     }},

    {"namespace", [](NODE_HANDLER) {
         os << Indent(indent) << "namespace";

         const auto name = node->first_attribute("id");
         if (name) {
             os << ' ' << name->value() << " {\n";
         }

         for (auto child = node->first_node(); child; child = child->next_sibling()) {
             Generate(child, os, indent + 1);
         }

         os << Indent(indent) << "} // namespace";
         if (name) {
             os << ' ' << name->value();
         }
         os << '\n';
     }},

    {"method", [](NODE_HANDLER) {
         auto name = node->first_attribute("id");
         auto ret = node->first_attribute("ret");
         auto sym = node->first_attribute("sym");

         os << Indent(indent) << TypeToString(ret->value()) << " " << name->value() << "(";
         for (auto child = node->first_node(); child; child = child->next_sibling()) {
             Generate(child, os, indent + 1);
             if (child->next_sibling())
                 os << ", ";
         }
         os << ") asm(" << sym->value() << ");\n";
     }},

    {"function", [](NODE_HANDLER) {
         os << Indent(indent);
         if (strcmp(node->parent()->name(), "object") == 0) {
             os << "static ";
         }

         auto name = node->first_attribute("id");
         auto ret = node->first_attribute("ret");
         auto sym = node->first_attribute("sym");

         os << TypeToString(ret->value()) << " " << name->value() << "(";
         for (auto child = node->first_node(); child; child = child->next_sibling()) {
             Generate(child, os, indent + 1);
             if (child->next_sibling())
                 os << ", ";
         }
         os << ") asm(" << sym->value() << ");\n";
     }},

    {"param", [](NODE_HANDLER) {
         auto name = node->first_attribute("id");
         auto type = node->first_attribute("type");

         os << TypeToString(type->value()) << " " << name->value();
     }},

    {"object", [](NODE_HANDLER) {
         auto name = node->first_attribute("id");
         auto sizeAttr = node->first_attribute("size");
         auto alignAttr = node->first_attribute("align");

         if (!name) {
             errs() << "missing name attribute\n";
             return;
         }

         auto size = sizeAttr ? sizeAttr->value() : "1";
         auto align = alignAttr ? alignAttr->value() : "1";

         os << Indent(indent) << "class " << name->value() << " {\n"
            << Indent(indent + 1) << "char __data[" << size << "];\n"
            << Indent(indent) << "  public:\n";

         for (auto child = node->first_node(); child; child = child->next_sibling()) {
             Generate(child, os, indent + 1);
         }

         os << Indent(indent) << "} __attribute((aligned(" << align << ")));\n";
     }}

};
#undef NODE_HANDLER

auto Generate(rapidxml::xml_node<> *node, std::ostream &os, size_t indent = 0) -> void {
    assert(node != nullptr);

    auto name = node->name();
    if (!Handlers.contains(name)) {
        errs() << "unrecognized tag '" << name << "'\n";
        return;
    }

    Handlers[name](node, os, indent);
}

auto main() -> int {
    std::vector<char> msm;
    for (char c; std::cin.get(c); ) {
        msm.push_back(c);
    }

    rapidxml::xml_document<> doc;
    doc.parse<0>(msm.data());

    Generate(doc.first_node(), std::cout);

    return Error ? EXIT_FAILURE : EXIT_SUCCESS;
}
